   Overview
　　With the mature of block chain 1.0 represented by Bitcoin and 2.0 represented by Ethereum, block chain has step out of the conceptual stage and entered the block chain 3.0 generation. Block chain 3.0 is an application beyond the scope of monetary and financial. It will fit up with a wide range of industries and demonstrate the true value of block chain to users.
　　A wide range of issues arise from the trust deficiency in foreign exchange. Although government and industry regulation (e.g., FCA, NFA, ASIC) has partially solved the problem of fraud in the foreign exchange, However, due to the information asymmetry between the transaction provider and the ordinary trader, there is still a wide range of behaviors such as Intentional side bet, intentional slippage, delay, and no payment. Due to the dispersion of the power of ordinary traders, rights protection is difficult.
　　We hereby put forward a solution that makes foreign exchange traders (can also be extended to other financial markets) a fair, just, open, safe, efficient and stable trade environment, preventing the trading platform to tamper with data or refuse to execute the trading result.
　　Foreign exchange chain FXCO (Forex Coin Omnipotent) is the world's first foreign exchange trading platform on block chain developed based on the block chain 3.0 architecture, which aims to provide a transparent foreign exchange trading environment for the broad trader.
　　The initial circulation of FXCO is 2.1 billion. The total amount is constant and cannot be additionally issued.
Chapter I Background
One. Industry background
　　Foreign exchange is the exchange of one country's currency with another. Unlike other financial markets, the foreign exchange market has no specific location or central exchange, but trades through electronic networks between banks, companies and individuals. 
　　Foreign exchange is traded in the form of currency pairs, such as the euro/dollar (EUR/USD) or USD/ yen (USD/JPY). The trader buys one currency in a currency pair and then sells another currency.
　　Foreign exchange market, also known as the "Foreign exchange" or "FOREX" market, is the world's largest financial market. More than $1.5 trillion is circulated daily -- Equivalent to 30 times of all the stock market in the United States.
　　With the economic globalization and the liberalization of financial transactions, the penetration and competitiveness of foreign exchange are increasing. Although large financial institutions and banks (as major market makers) occupy half of the foreign exchange market, the development of modern technology also makes foreign exchange widely accepted by the public. Foreign exchange brokers have developed easy-to-use online trading platforms and simplify trading processes, which enable them to trade almost anywhere in the world.
　　There are 3.8 billion Internet users in global, and one out of every 396 Internet users is an online trader. According to statistics, there are 9.6 million online traders worldwide. Although the USA and UK remain the largest foreign exchange trading centers so far, one in three online traders are now in Asia or the Middle East. Asia has 1.9 billion Internet users and 3.2 million online traders.
　　According to the triennial survey of the Bank for International Settlements (BIS), the daily turnover of the global foreign exchange market is $6 trillion, about 53 times of the New York stock exchange. The foreign exchange market is four times of the global GDP. As the world's largest financial market, foreign exchange market has always been favored by investors. In the global foreign exchange market transaction, more than 85% of transactions occur in seven major currency pairs: EUR/USD; USD/JPY; GBP/USD; AUD/USD; NZD/USD; USD/CAD; USD/CFH.
Two. Market pain point
　　Because of the wide trading range, information asymmetry and extremely dispersed participants of foreign exchange, there are many problems in this market, mainly including:
　　1. Intentional Side bets: Foreign exchange trading platforms do not submit the transaction proposed by investors to the bank or large institutions, but using its own funds to hedge and bet with the investors. It is very dangerous and totally fraud in the absence of regulation.
　　2. Intentional slippage: Slippage refers to the difference between the price of the list and the final transaction price when the trader makes the deal. There are two main reasons for slippage: one is due to network fluctuation or server delay. The other is due to the excessive fluctuation of the market. So no platform can completely avoid slippage. Some platforms, however, use the rule to steal investors' assets through intentional slippage.
　　3. Delay: the execution speed is the most important in foreign exchange, and high delay would make a potential profitable trading suffer huge loss. There are a number of corrupted platforms that intentionally delay trading through technical means, causing disastrous losses to investors.
　　4. No payment: Many corrupted platforms will block investors' funds, and investors will not be able to withdraw their funds regardless of making loss or profit.
　　To sum up, we can see that there are many problems in foreign exchange trading. Significant bottlenecks exist during its development in the existing technology mode.
　　How to solve these problems?
Three.  Solution
　　(1) Problem analysis
　　The above problems are complicated. But if we see the essence through the phenomenon, these problems stem from the trust deficiency between different trading main-body in different link. Due to the trust deficiency and opacity, the cost of the transaction increases and the efficiency declines. Driven by profit, vicious intentions are induced by the bad system and many problems are emerged. More importantly, the increase of links will magnify the effects of trust deficiency further, which is the intrinsic problem in foreign exchange transactions.
　　In order to solve these problems, we must solve the problem of the mutual trust between trading main-body in different link. Since these problems exist from the human birth and accompany with the development of the society thereafter, it is difficult to fundamentally solve these problems through traditional technology or modal transformation. This requires the introduction of new technology.
　　(2) Concept of block chain.
　　Block chain is the core technology behind Bitcoin. It is essentially a decentralized database. Narrowly speaking, chain block is a chain of data structure that connecting data blocks according to the time sequence, a distributed accounting book that guaranteed by cryptography, tamper-resistant and unforgeable. General speaking, block chain technology is a new kind of distributed architecture and computing paradigm which using block chain to verify or store data, to generate and update data with distributed nodes and consensus algorithm, to ensure the security of data transmission and access with cryptography, to programming and operating data with smart contract composed of automation scripts. Generally, block chain technology refers to a way for all traders to participate in bookkeeping. There is a database behind every software system that we use. If you think of the database as a big ledger, then it becomes important who writes the account.
　　In the existing technology, every software system is responsible for the accounting to itself. Tencent is responsible for WeChat. Alibaba is responsible for Taobao. In the block chain system, everyone has a chance to participate in the accounting. Within a certain period of time, system only records those data changes that recognized by most people in the system and writes the change to the accounting book, then distributes to all people within the system and synchronize with all of them. So everyone in the system has a complete and consenting ledger. We call this kind of billing method block chain technology.
　　(3) Advantages of block chain technology.
　　The advantages are obvious to accounting by the block chain technology, including:
　　1, Safety: there is no central accounting book in block chain system (decentralized), and therefore cannot totally control by anybody. The ledger is distributed in each node of the network. Rights are equal in each node, and the accounting book is the same. Destruction of some nodes has no effect on the whole system.
　　2, Reliable: Once the verified information is added to the block chain, it will be permanently stored. Unless more than 50% of the node in the whole system was controlled at the same time, otherwise it is useless to modify the data on a small number of nodes. The hackers may have the ability to control a computer to change the information, but the system will consult the opinions of the majority to decide what the real result is. The hacker will find it makes no sense to modify a few accounting books (because other node does not approve). To modify the majority of nodes has to go against the entire network which would cause unbearable cost. More harm comes out than good.
　　3. Smart contracts: Smart contracts are contracts that replace legal language with computer language to record terms. Smart contracts are executed automatically in accordance with the agreed terms. From a user's point of view, a smart contract is often considered as an automatic security account. For example, when certain conditions are met, the program releases and transfers funds.
　　From a technical perspective, smart contract is regarded as a network server, but the server is built on the internet using IP address, but set up on the block chain, which the particular contract can run on. The potential benefits of smart contracts include reducing the cost of contracts, enforcement and regulation; therefore, for those contract related with capital, the cost of manpower and trust are greatly reduced.
　　(4) The significance of block chain technology 
　　Objectively, block chain technology can solve many problems in the aforementioned foreign exchange market.
　　1, Decentralization: Based on the characteristics of decentralization in foreign exchange trading, each trading main body can be seamlessly connected to the chain and become an individual node, thus reducing dependence to the center structure. And the transaction data, historical records and comment in each node is inalterable, which can significantly improve the credibility in the trading.
　　2. Openness: the data of block chain is open to all. Anyone can query the block chain data or develop related applications through an open interface. Therefore, the whole system information is highly transparent. In foreign exchange transactions, the application can avoid shady deals and improve service efficiency.
　　3. Reliability: the block chain is essentially a huge "de-centralization" ledger database. It's spread over every branch node. In foreign exchange transactions, each participant has a ledger. Transaction data is recorded directly on the ledger of all participants, and cannot be modified by individual participants. And the modification can be traced back. Therefore, the risk of data loss or tampering is eliminated. Since the data cannot be intervened by any third party, the transaction data are fully credible. Traceability, irreversibility, unforgeability. Those advantages consolidate each transaction.
　　4. Security: The block chain technology is open source. The tokens are generated by massive calculations of graphics card or CPU based on the open source code. Moreover, the private information of all parties involved in the transaction is fully encrypted, which can ensure the security of funds circulating in all links of and not reveal personal privacy.
　　5. Smart contract: There are a lot of trading behaviors in foreign exchange, including asset transaction, cash flow and so on. All these actions bind a smart contract in the process of trading. The system will automatically execute the contract content. Intentional slippage, delay and no payment will no longer exist.
　　As can be seen from the above contents, the advantages of the block chain, decentralization, openness, security, transparency and smart contract, have fundamentally solved the trust problem between the trading bodies in different links. This solution is done from the basic technology and can fundamentally solve many problems existing in foreign exchange.
Chapter Two. Project description
One. Project outline
　　Forex coin omnipotent is a trading network that provides foreign exchange traders with a fair, just, open, safe, efficient and stable foreign exchange trading environment on block chain. FXCO is a chain of alliances which developed within the MIT license agreement. In the future, we will also provide API or SDK to help developers build decentralized applications in financial markets.
　　FXCO includes the application of decentralized foreign exchange trading, transaction data depositing, token ecosphere of constant trading asset, and multi-thread matching engine on the chain.
　　FXCO will successively login the major exchanges and open up the exchange channel between legal currency and mainstream virtual currency.
　　All currency pair trading in the main chain must first inject FXCO into the contract. And the exchange rate of FXCO and the dollar (or other currency) is quoted in real time by the trading providers on the chain.
　　By injecting FXCO into the transaction contract, the transaction result would be 100% executed by the contract. And there will be no default, no matter who the counterparty is. Traders' trading positions are linked 100% to the trading results, ensuring that each participant's capital is safe.
　　Most of the foreign exchange markets are now brokered by Reuters, forming our common currency market quotes.
　　Multithreaded matching on the FXCO chain will produce prices that reflect the will of the real market by the decentralized environment.
　　To sum up, the emergence of FXCO is expected to solve the problems existing in traditional foreign exchange transactions.
　　Based on the data depository and transparent of block chain, the injection of FXCO into the trading contract will guarantee the execution of the transaction results. The gradual expansion of the main chain will put the entire foreign exchange industry in the sun.
Two. Function module
　　FXCO is based on the following major application modules:
Module name
Module contents
Basic block chain module
1. Communication function within block chain node 
2. Consensus and anti-Byzantine mechanism in block chain
3. Data encryption mechanism in block chain
4. Block chain account system
Alliance management module
1. Network function of alliance node 
2. Entry function of alliance node
3. Exit function of alliance node
4. List function of alliance node
Node certificate module
1. Establishment mechanism of node certificate system 
2. Broadcasting mechanism of node certificate
3. Revocation mechanism of node certificate
Foreign exchange asset issuance module
1. Issuance mechanism of foreign exchange asset 
2. Gateway function of foreign exchange asset 
3. Commission charges of foreign exchange asset 
Smart contract module
1. Establishment of smart contract
2. Deployment function of smart contract
3. Call function of smart contract
4. Query function of smart contract
5. Template of smart contract
Matching engine module
1. Declaration mechanism of foreign exchange assets (including the establishment of the declaration and cancellation of the declaration)
2. Matching mechanism of foreign exchange assets
3. Commission charges of foreign exchange assets matching
4. Six degree matching mechanism of foreign exchange assets
Three. Technical features and advantages
　　Massive data test and analysis results show that the FXCO block chain can be achieved in: millisecond trading verification, mass data storage, high throughput and fast synchronization of node data. In terms of extensibility, functions such as multi-business block structure, authority control strategy, transaction endorsement strategy, channel management strategy, etc. can be realized. At the same time, we also provide secure private key access services, as well as improved privacy protection.
　　（1）Performance
　　1. Quick transaction verification.
　　By optimizing the key links such as signature algorithm, ledger structure, data manipulation, serialization, consensus mechanism, and message diffusion, FXCO block chain can realize quick transaction verification of second level, satisfying the user experience in most block chain application scenarios.
　　2. Massive data storage.
　　In the model of double-entry accounting, the historical data is accumulating continuously in the block chain as the system keep running; Adopted with the mechanism of isolating and storing the cold and heat data in traditional financial system, FXCO realized effective storage of massive data.
　　3. High throughput
　　The essence of block chain is a kind of distributed and shared bookkeeping technology. It is mainly reflected in distributed consistency rather than distributed concurrency. In order to ensure the consistency of the data, to prevent the Byzantine general problem, certain links can only be executed in serial, not in parallel. Through long-term testing and optimization practice, the processing performance of FXCO block chain can meet the requirements of 10,000 TPS. If we introduce the off-chain mechanism, we can further increase the transaction throughput significantly.
　　4. Fast synchronization of node data
　　FXCO block chain support image mechanism (Snapshot) which can be used to regularly make image of the local accounts to realize rollback mechanism. Under the unified consensus, the specified image label can be rolled back. At the same time, the operation cycle of the newly added node is shortened. After synchronizing the latest image and a small number of recent transaction sets, it can be integrated into the network and participate in the consensus verification.
　　(2) Extensibility
　　1. Block chain structure that competent with Multi-business.
　　The block chain structure of FXCO can meet the needs of different business areas and improve the system's scalability and maintenance efficiency.
　　It can be used to mark assets and asset transfers, or to provide unchangeable multidimensional event records, and can also be used to trace the source the flow of assets.
　　2. Access control strategy
　　Two kinds of access control strategy are provided: writing and reading of data information. Writing permission: multiple users are set up under the same account, and corresponding permissions are set for different operations to meet the usage of multi-signature control. Reading permission: the user can grant and cancel the right of a single user or user group to operate the data. The user group can be configured by the user flexibly.
　　Data includes user account information, transaction information, and so on. It can be controlled down to every individual field of the transaction or account.　　

　　Fig. 2-1 access control strategy.
　　(3) Safety
　　1. Secured private key access
　　In order to facilitate the usage of the block chain product service, FXCO provides network managed access and private key hardware access (u-key), in addition to the traditional client generation and storage mechanism. Network managed access is that the user name and password are mapped to private keys by a specific algorithm and stored on the server. The private key stored on the server side is encrypted data, and the private key can only be decrypted by the client. The hardware private key is specially made to meet the needs of the financial industry.

　　Fig. 2-2 Secured private key access
　　2. Multiple privacy protection
　　Multiple privacy protection functions are provided. First, the block chain layer provides the homomorphic encryption method. All data of the user is encrypted and stored; only the user can see it. Second, FXCO provides encrypted middleware services. It is an option for the user according to business needs. Finally, the upper-layer application can encrypt data during entry. The FXCO platform operates the writing and reading of encrypted data generated by users.
Four. Applications
　　[Foreign exchange institute]
　　Foreign exchange transactions involve multiple links, and a liquidation failure of a large transaction would trigger a series of defaults.
　　For example, cross-border settlement of funds is only conducted within the working time of the central bank of the currency. And the clearing parties may be in different time zones. If one side of the foreign exchange is liquidated before the other, the party waiting for the settlement will be at risk of default. If foreign exchange traders pay the currency they are dealing with without getting their due currency at the same time, foreign exchange traders will be exposed to the risk of rate fluctuations or loss of their due currency. The risk arises from the non-synchronization of payment of both parties. On the other hand, international trading lacks a centralized and unified regulatory body, so the supervision of foreign exchange transactions has always been a problem in the industry.
　　The foreign exchange platform built on FXCO is a self-consistent information technology solution to the trust deficiency and to reduce the cost of trust. The integrity of data can be guaranteed without credit accumulation. All data is recorded on irreversible block chains. Therefore, the centralized verification of identity card is eliminated in the foreign exchange transaction. The whole process is completely transparent, safe and easy to track. That would help brokers speed up clearing and settlement of trades, which would greatly reduce the risk of trading. Moreover, the data of the block chain has the system self-verification record, no authentication, no supervision department data collection, no need to report to the enterprise. This will greatly reduce regulatory costs and improve regulatory efficiency. At the same time, due to the stability and reliability of the data block, the block chain technology is intrinsically accurate and safe in data in the application of foreign exchange supervision. In addition, the irreversibility of data blocks and the traceability of data nodes provide great convenience for supervision and improve the efficiency of supervision.
　　[Anti-fraud]
　　Fraud and counterfeiting are the main risks of central foreign exchange trading institutions. The use of foreign exchange chain can effectively prevent fraud and false behavior. In the block chain, data is recorded and stored by each transaction node. Each node can participate in the data check and verify the data together, which improves the reliability of the data. Individual nodes are not allowed to add or subtract data freely, thus reducing the possibility of manipulating false data by single node. For example, as a private chain is created within the trading platform, every customer constitutes a node. On the one hand, it avoids massive data was input and stored by one single information center, thus reducing operational risk. On the other hand, unilateral falsification can be suppressed by verification which guarantees the authenticity and effectiveness of data. If the manipulated data is to be verified by the block chain network, more than 50% of the computing power in the private chain must be mastered. When there are enough nodes, the cost of controlling the private chain increases dramatically. In addition, each node in the block chain has a complete copy of the data. So it can be only lost when the node on the entire block chain is down. And data records cannot be modified once written.
　　Therefore, the openness, transparency and security of the block chain can improve the data quality fundamentally and enhance the inspection ability of the data.
Chapter Three System core architecture
One、System logistic structure
Figure 3-1 shows the system logic architecture diagram designed by FXCO

Fig. 3-1 Diagram of system logic structure
The system logic architecture diagram shown in figure 3-1 is divided from different perspectives. The upper layer provides the standard gRPC interface from the perspective of the application. The SDK of different languages is encapsulated on the basis of the API, including Golang, node.js, Java, Python, and so on. Developers can use the SDK to develop a block-chain-based application. Consistency is very important in block chain which requires long execution time to consensus with different nodes. It is also developed with asynchronous communication. The event module can perform a predefined callback function when a block event or chain code event is triggered. Here are a few things concerns about the application and the basic layer.
1．Application
　　（1）Identity management
　　After registers and logs in the system, the user gets the registration certificate (ECert). All other operations need to be signed with the private key associated with the user certificate. The message receiver will first verify the signature and then proceed with subsequent message processing. Network nodes also use issued certificates. System startup and network node management will authenticate?and?authorize user’s identity.
　　（2）Accounting book management
　　Authorized users can query the ledger data, which can be queried in multiple ways, including searching blocks with block number, block Hash or transaction number, or searching the deal with transaction number, and searching the massage of block chain with channel number.
　　（3）Transaction management
　　The ledger data can only be updated through transaction execution. When the application program submits proposal and fetches the endorsement, it will propose the transaction to the ordering service node and package it into blocks. SDK will provide the interface and create the transaction number locally with the user Ecert. Endorsement and accounting node will check the possibility of duplicate transactions.
　　（4）Smart contract
　　Our object is programmable ledger. Transactions executed by chain code will realize the business logic based on the smart contract of block chain. Only smart contracts can update the accounting data, and other modules cannot directly modify the World State.
2．Basic layer
　　The following content shows how to realize distributed ledger technology and provide block chain service to the application by FXCO.
　　（1）User management
　　The MSP (Membership Service Provider) abstracts member management. Public Key Infrastructure authenticates members and verifies the signature of the proposal submitted by member user. Combined with a Fabric-CA or a third party CA system, the membership registration function is provided and the membership certificate is managed, such as certificate addition and revocation. The registered certificates are divided into registration certificates (ECert), transaction certificates (TCert) and TLS Cert (TLS Cert), which are used for user identity, transaction signing and TLS transmission respectively.
　　（2）Consensus service
　　To make sure the consistency of different blocks at various nodes within one chain and the efficiency and order of transactions within blocks, the consensus service will be accomplished in three stages: the client submits proposals to the endorsement node to endorse, the client submits the endorsed transaction to the rank node and generates block and transaction number, then it broadcasts the transaction to the accounting node for checking and writes into local account book. The P2P protocol of network node adopts the data distribution based on the Gossip, and synchronizes the data with the same organization to promote the efficiency of network transmission.
　　（3）Chain code service
　　The implementation of smart contracts relies on a secure environment to ensure the security of the execution process and the isolation of user data. Docker is used to operating ordinary chain code, providing a safe sandbox environment and a warehouse for image files, which makes FXCO multi-language support and very extensible. Docker's solution also has its own problems, such as higher environmental requirements, more resources occupation and lower performance. There are also compatibility problems with Kubernetes, Rancher and other platforms in the implementation process.。
　　（4）Safety and password service
　　Security issues are concerned by the enterprise-class block chain, especially in projects that focus on national security. Cryptographic support is particularly important. FXCO specifically defines a BCCSP (BlockChain Cryptographic Service Provider) to enable key generation, hash operation, signature verification, encryption and decryption, and other basic functions. BCCSP is a virtual interface, and the default algorithm is the national standard algorithm of soft implementation. Currently, the community and most manufacturers are focusing on the national security algorithm and HSM (Hardware Security Module).
Two、Network node architecture
　　Node is the communication body of block chain, and it is a logical concept. Multiple different types of nodes can run on the same physical server. There are many types of nodes: client, Peer, ordering service, and CA nodes. Figure 3-2 shows the network node architecture diagram.
　　In the following explains the types of different nodes shown in figure 3-2.
1．The client
A client or application represents an entity that is operated by a user and must be connected to peer nodes or ordering service nodes to communicate with the block chain network. The client submits the Transaction Proposal to the Endorser (Endorser). When sufficient endorsement is collected, the proposal is broadcasted to the ordering service and block is then generated.
2．Peer 
　　All Peer nodes are accounting nodes (committers) that verify transactions in the ordering service node and maintain a copy of the status data and ledger. Some nodes execute the transaction and endorse the result, acting as the endorsement node. An endorsement node is a dynamic role that is bound to a specific chain code. Each chain code is instantiated with an endorsement policy specifying which nodes are valid after the transaction is endorsed. Those nodes are valid only when the application makes a trade endorsement request to them. In the other time, they are common billing nodes, which are responsible for verifying transactions and keeping accounts. 

　　Fig. 3-2 Diagram of network nodes
　　As shown in figure 3-2, Peer node plays another role as the master node (Leader Peer), acting as communication nodes with ordering service node and fetching new blocks from ordering service node and synchronization within the organization. Peer node can be set as the Leader Peer, also can be elected dynamically.
　　As can be seen in figure 3-2, some nodes are both the endorsement node and the billing node, and can also be the endorsement node, the master node and the billing node, or just the billing node.。
3．Ordering service node
　　The sorting Service Node (Ordering Service Node or Orderer) receives the endorsed transaction, sorts the unpackaged transaction into blocks, and broadcasts it to the Peer Node. The sorting node provides Atomic Broadcast, ensuring that nodes on the same chain receive the same message and have the same logical order.
　　The multi-channel of the sorting service realizes the isolation of multi-chain data, ensuring that only the Peer node of the same chain can access the data on the chain. Thus the privacy of user data is protected.
　　Sorting services can be centralized or distributed. Different levels of fault tolerance can be achieved. Now the officially released version only supports the Apache Kafka cluster, providing trading sort function. Only CFT (Crash Fault Tolerence) is supported but not the BFT (Byzantine Fault Tolerance).
4．CA 
　　The CA node is FXCO's Certificate Authority, which is composed of server and client. The CA node receives the registration application from the client and returns the registration password for the user to log in to obtain the identity certificate. Any operations on the blockchain network needs to verify the user's identity. CA nodes are optional and can be issued with other mature third-party CAs.
Three、Typical transaction process
Figure 3-3 shows the typical trading flow chart of FXCO.

　　Fig. 3-3 Flow chart of trading in FXCO
　　From the network node architecture in the previous section, we have learned that FXCO's block chain application involves several nodes: application, indorse node, ordering service node, and Leader Peer.
　　In figure 3-3, assumed that each node has already issued the certificate in advance, and started normally, and has been added to the created channel. The following steps describe the process from initiating a call transaction to the final bookkeeping in the chain code channel that has been instantiated.
　　1. Create the transaction proposal and send it to the endorsement node.
　　Using the application to construct a transaction proposal, the structure of SignedProposal is as follows:
SignedProposal：{
　　ProposalBytes（Proposal）：{
　　　　Header：{
　　　　　　ChannelHeader：{　　　　　　　　
Type："HeaderType_ENDORSER_TRANSACTION",
　　　　　　　　TxId：TxId,
　　　　　　　　Timestamp：Timestamp,
　　　　　　　　ChannelId：ChannelId,
　　　　　　　　Extension（ChaincodeHeaderExtension）：{
　　　　　　　　　　PayloadVisibility：
PayloadVisibility,
　　　　　　　　　　ChaincodeId：{
　　　　　　　　　　　　Path：Path,
　　　　　　　　　　　　Name：Name,
　　　　　　　　　　　　Version：Version
　　　　　　　　　　}
　　　　　　　　},
　　　　　　　　Epoch：Epoch
　　　　　　},
　　　　　　SignatureHeader：{
　　　　　　　　Creator：Creator,
　　　　　　　　Nonce：Nonce
　　　　　　}
　　　　},
　　　　Payload：{
　　　　　　ChaincodeProposalPayload：{
　　　　　　　　Input（ChaincodeInvocationSpec）：{
　　　　　　　　　　ChaincodeSpec：{
　　　　　　　　　　　　Type：Type,
　　　　　　　　　　　　ChaincodeId：{
　　　　　　　　　　　　　　Name：Name
　　　　　　　　　　　　}，
　　　　　　　　　　　　Input (ChaincodeInput):{
　　　　　　　　　　　　　　　Args：[]
　　　　　　　　　　　　}
　　　　　　　　　　}
　　　　　　　　},
　　　　　　　　TransientMap：TransientMap
　　　　　　}
　　　　}
　　},
　　Signature：Signature
}
As can be seen from above, SignedProposal is a structure that encapsulates the Proposal and the signature information of the caller. The endorsement node verifies whether it is a valid message based on the signature information. A Proposal consists of two parts: the header and the message structure.
　　The header also consists of two parts:
　　1）ChannelHeader：The channel header contains information related to the invocation of channel and chain code, such as which version of the chain code is invoked on a specific channel. TxId is the transaction number generated locally by the application, which is related to the identity certificate of the caller. To avoid the conflict of the transaction number, both the endorsement node and the billing node will check if there is a duplicate transaction. 
　　2）SignatureHeader：The signature header contains the caller's identity certificate and a random number which are used to validate the message.
After the construction of the transaction proposal, the application will select the endorsement node to execute and endorse. The endorsement nodes are nodes that specified in the chain code endorsement policy. When some of the endorsement nodes are offline, other endorsement nodes can refuse to endorse the transaction. Other available endorsement nodes would be tried to satisfy the policy. It does not matter in which order the application send the endorsement request to the endorsement node. Normally, the execution results of different endorsement nodes are consistent, except the signature.
2．The endorsement node simulates the transaction and generates an endorsement signature.
Some verification will be performed after the endorsement node received the transaction proposal, including:
* The format correction of the proposal；
* Duplication proposal check (Prevent repeated attacks)；
* The validation of signature（Via MSP）；
* Write permission of the proposal submitted on the current channel
After verification, the indorsing node will simulate the transaction with the chain code logic and generate the read-write set (Rawest) based on the current account data, including the response value, read-write set, and so on. The ledger will not be updated during the simulation. Then the endorsement node signs the read-write set into Proposal Response and returns it to the application. The structure of a ProposalResponse is as follows:
ProposalResponse：{
　　Version：Version,
　　Timestamp：Timestamp,
　　Response：{
　　　　Status：Status,
　Message：Message,
　　　　Payload：Payload
　　},
　　Payload（ProposalResponsePayload）：{
　　　　ProposalHash：ProposalHash,
　　　　Extension（ChaincodeAction）：{
　　　　　　Results（TxRwSet）：{
　　　　　　　　NsRwSets（NsRwSet）：[
　　　　　　　　　　NameSpace：NameSpace,
　　　　　　　　　　KvRwSet：{
　　　　　　　　　　　　Reads（KVRead）：[
　　　　　　　　　　　　　　Key：Key,
　　　　　　　　　　　　　　Version：{
　　　　　　　　　　　　　　　　BlockNum：BlockNum,
　　　　　　　　　　　　　　　　TxNum：TxNum
　　　　　　　　　　　　　　}
　　　　　　　　　　　　],　　　　　　　　　　　　
RangeQueriesInfo（RangeQueryInfo）：[
　　　                      StartKey：StartKey, 　　　　　　　　　　　　　　
　　　　　　　　　　　　　　EndKey：EndKey,
　　　　　　　　　　　　　　ItrExhausted：ItrExhausted,
　　　　　　　　　　　　　　ReadsInfo：ReadsInfo
　　　　　　　　　　　　],
　　　　　　　　　　　　Writes（KVWrite）：[
　　　　　　　　　　　　　　Key：Key,
　　　　　　　　　　　　　　IsDelete：IsDelete,
　　　　　　　　　　　　　　Value：Value
　　　　　　　　　　　　]
　　　　　　　　　　}
]
　　　　　　Events（ChaincodeEvent）：{
　　　　　　　　ChaincodeId：ChaincodeId,
　　　　　　　　TxId：TxId,
　　　　　　　　EventName：EventName,
　　　　　　　　Payload：Payload
　　　　　　}
　　　　　　Response：{
　　　　　　　　Status：Status,
　　　　　　　　Message：Message,
　　　　　　　　Payload：Payload
　　　　　　},
　　　　　　ChaincodeId：ChaincodeId
　　　　}
　　},
　　Endorsement：{
　　　　Endorser：Endorser,
　　　　Signature：Signature
　　}
}
　　The returned ProposalResponse contains information including read-write sets, endorsement node signatures and channel names, etc.
3．Collect the endorsement of the transaction.
　　When a ProposalResponse is received, the application verifies the signature of the endorsement node. Any message received by any node has to be validated first. If the chain code only performs an accounting query, the application will check the query response, but will not submit the transaction to the sorting service node. If the chain code performs an Invoke operation on the ledger, the transaction has to be submitted to the sorting node to update the ledger. The application will determine whether the endorsement policy is satisfied before the transaction is submitted. If the application commits the transaction without enough endorsements, the billing node will find that the transaction does not satisfy the endorsement strategy during the validation stage and marked it as an invalid transaction.
How to select an endorsement node? The fabric-SDK-go will define all nodes in the configuration file (channels. Mychannel. Peers, where Mychannel should be replaced by the actual channel name) as endorsement nodes by default, and all endorsement signatures of every node are required.
The timeout time that the application waited for the execution of each node is set by the configuration file (client.peer.timeout.connection). The time in the example of the configuration file is 3 seconds and can be  adjusted according to the actual situation. If there is no setting, the default value is 5 seconds.
4. Construct the proposal and send it to the sorting node
After receiving all the endorsement signatures, the application calls the SDK to generate the transaction proposal and broadcast it to the sorting node. The process of generating transactions is simple.
When the execution results of all the endorsement nodes are Verified to be identical, the transaction proposal, proposal response and endorsement signature will be packaged into a transaction. The structure of the transaction is as follows:
Envelope：{
　　Payload：{
　　　　Header：{
　　　　　　ChannelHeader：{　　　　　　　　
Type："HeaderType_ENDORSER_TRANSACTION",
　　　　　　　　TxId：TxId,
　　　　　　　　Timestamp：Timestamp,
　　　　　　　　ChannelId：ChannelId,
　　　　　　　　Extension（ChaincodeHeaderExtension）：{
　　　　　　　　　　PayloadVisibility：
PayloadVisibility,
　　　　　　　　　　ChaincodeId：{
　　　　　　　　　　　　Path：Path,
　　　　　　　　　　　　Name：Name,
　　　　　　　　　　　　Version：Version
　　　　　　　　　　}
　　　　　　　　},
　　　　　　　　Epoch：Epoch
　　　　　　},
　　　　　　SignatureHeader：{
　　　　　　　　Creator：Creator,
　　　　　　　　Nonce：Nonce
　　　　　　}
　　　　},
　　　　Data（Transaction）：{
　　　　　　TransactionAction：[
　　　　　　　　Header（SignatureHeader）：{
　　　　　　　　　　Creator：Creator,
　　　　　　　　　　Nonce：Nonce
　　　　　　　　},
　　　　　　　　Payload（ChaincodeActionPayload）：{
　　　　　　　　　　ChaincodeProposalPayload：{　　　　　　　　　　　　
Input（ChaincodeInvocationSpec）：{
ChaincodeSpec：{
　　　　　　　　　　　　　　　　Type：Type,
　　　　　　　　　　　　　　　　ChaincodeId：{
　　　　　　　　　　　　　　　　　　Name：Name
　　　　　　　　　　　　　　　　},
　　　　　　　　　　　　　　　　Input（ChaincodeInput）：
　　　　　　　　　　　　　　　　{
　　　　　　　　　　　　　　　　　　Args：[]
　　　　　　　　　　　　　　　　}
　　　　　　　　　　　　　　}
　　　　　　　　　　　　},
　　　　　　　　　　　　TransientMap：nil
　　　　　　　　　　},
　　　　　　　　　　Action（ChaincodeEndorsedAction）：{　　　　　　　　　　　　
Payload（ProposalResponsePayload）：{
　　　　　　　　　　　　　　ProposalHash：ProposalHash,　　　　　　　　　　　　　　
Extension（ChaincodeAction）：{
　　　　　　　　　　　　　　　　Results（TxRwSet）：{
　　　　　　　　　　　　　　　　　　NsRwSets（NsRwSet）：[
　　　　　　　　　　　　　　　　　　　　NameSpace：NameSpace,
　　　　　　　　　　　　　　　　　　　　KvRwSet：{
　　　　　　　　　　　　　　　　　　　　　　
　　　　　　　　　　　　　　　　　Reads（KVRead）：[
　　　　　　　　　　　　　　　　　　　　　　　　Key：Key,
　　　　　　　　　　　　　　　　　　　　　　　　Version：{
　　　　　　　　　　　　　　　　　　　　　　　　　　
　　　　　　　　　　　　　　　　　　　　　　　　　　BlockNum：BlockNum,
　　　　　　　　　　　　　　　　　　　　　　　　　　TxNum：TxNum
　　　　　　　　　　　　　　　　　　　　　　　　}
　　　　　　　　　　　　　　　　　　　　　　],　　　　　　　　　　　　　　　　　　　　　　
RangeQueriesInfo（RangeQueryInfo）：[
StartKey：StartKey,
EndKey：EndKey,　　　　　　　　　　　　　　　　　　　　　　　　
ItrExhausted：ItrExhausted,
ReadsInfo：
ReadsInfo
　　　　　],
　　　　　　　　　　　　　　　　　　　　　　
Writes（KVWrite）：[
　　　　　　　　　　　　Key：Key,
　　　　　　　　　　　　IsDelete：IsDelete,
　　　　　　　　　　　　Value：Value
　　　　　　　　　　　　　　　　　　　　　　]
　　　　　　　　　　　　　　　　　　　　}
　　　　　　　　　　　　　　　　　　]
　　　　　　　　　　　　　　　　},
　　　　　　　　　　　　　　　　
Events（ChaincodeEvent）：{
　　　　　　　　　　　　　　　　　　ChaincodeId：ChaincodeId,
　　　　　　　　　　　　　　　　　　TxId：TxId,
　　　　　　　　　　　　　　　　　　EventName：EventName,
　　　　　　　　　　　　　　　　　　Payload：Payload
　　　　　　　　　　　　　　　　}
　　　　　　　　　　　　　　　　Response：{
　　　　　　　　　　　　　　　　　　Status：Status,
　　　　　　　　　　　　　　　　　　Message：Message,
　　　　　　　　　　　　　　　　　　Payload：Payload
　　　　　　　　　　　　　　　　},
　　　　　　　　　　　　　　　　ChaincodeId：ChaincodeId
　　　　　　　　　　　　　　}
　　　　　　　　　　　　},
　　　　　　　　　　　　Endorsement：[
　　　　　　　　　　　　　　Endorser：Endorser,
　　　　　　　　　　　　　　Signature：Signature
　　　　　　　　　　　　]
　　　　　　　　　　}
　　　　　　　　}
　　　　　　]
　　　　}
　　},
　　Signature：Signature
}
　　The Signature of the Envelope is the Signature for the entire Envelope.Payload of the transaction committer. The application can send the envelope to several arbitrarily chosen sorting service nodes.
　　5. The sorting node sorts the transaction and generates the block.
　　The sort service does not read the transaction. If the transaction simulation execution is falsified when the transaction envelope is generated, the sorting service node will not found out. But it will be checked out at the last verification of the transaction and marked as invalid transactions. The sorting service is simple. It firstly receives the transaction from all channels in the network, reads the Envelope.Payload.Header.ChannelHeader.ChannelId of the transaction for channel names, sorts the transaction according to the receiving time sequence on each channel and finally generates the block. 
6．The sorting node broadcasts the transaction to the Leader node
   The block generated by the sorting node will be broadcasted to the leader nodes of different organizations on the channel.
　　7. The accounting node validates the block content and writes it into the block
　　The endorsement node is dynamic. Any node that participated in the endorsement of a transaction is an endorsement node.
　　Endorsement nodes of the transactions are selected by the application as long as the endorsement strategy is satisfied. All endorsement nodes are accounting nodes. All Peer nodes are also accounting nodes that recording the data added to the channel by the current node. The account node receives the block generated by the sorting service node, verifies the validity, and then produces an event of the block generation after the local ledger is submitted. Subsequent operation is then applied by applications that monitoring the block events. If the received block is a configuration block, the cached configuration information is updated.
　　The flow chart of the accounting node is shown in figure 3-4.
Fig. 3-4 Diagram of process of the accounting node
1) Verification of transaction data
The validation of block data is based on transaction validation. Each time the block is validated, a bitmap txValidationFlags of the transaction number is generated. It records the transaction verification status of each transaction number. Only if the status is TxValidationCode_VALID, the block is valid. Bitmaps are also written into the block's metadata (BlockMetadataIndex_TRANSACTIONS_FILTER).
The following contents will be checked for transaction verification:
* Validity of the transaction: the correction of the format, the validity of signature, tampered or not;
* Join of the accounting node into the channel
　　When the transaction passed the basic verification, it will be submitted to VSCC for the validation of the endorsement policy.
　　2) Accounting node and VSCC
　　Chain code transactions are segregated. Each TxRwSet of the simulated execution result contains the chain code it belongs. In order to avoid updating the chain code transaction data mistakenly, the chain code will be checked before the transaction is submitted to VSCC.
　　3) Verification of the data status and MVCC inspection
　　After the transaction is checked through VSCC, it enters the accounting process. The kvledger will perform a MVCC (multi-version Concurrency Control) to the TxRwSet.
　　The implementation of kvledger is based on the state data model in terms of key-value. There are three operations on the key of status data:
* Read the status data
* Write the status data
* Delete the status data
There are two ways to read status data:
* Read based on single key;
* Read based on a key range
　　The MVCC check only verifies the read data.
　　The basic logic is to compare the two versions of the status data in the simulation execution and the submission of the transaction. If the data version or the range of a key changed, it indicates that other transactions have changed the status data within that time. The current transaction based on the original state of processing is problematic. Since transaction submission is parallel, the final execution order cannot be determined before the transaction is packaged into a block. If the order in which the transaction is executed is relevant, the associated status will be changed during the MVCC check. Actually, the data is in conflict. Figure 3-6 shows a flowchart of state-based data validation.
　　The write collection contains the data of write and delete, and there is a status flag to delete the data. In order to improve efficiency, the submission of the status database is a batch process. The status data of the entire block transaction is submitted simultaneously. This also ensures that the submission of status data of the entire block is either success or failed completely. At this time, only the recorded accounting data and the status database are inconsistent, and there will be no inconsistent in the status data of the block. When the ledger data is inconsistent with the status database, it can be marked by the checkpoint of the status database.

Fig. 3-5 Flowchart of validation based on status data
　　4) Management of invalid transactions
　　False trade leads to invalid transaction. Normal transaction may also produce invalid transaction. The MVCC checks the environment consistency between the simulated execution of the endorsement node and the transaction submission of the accounting node. The environment refers to the consistency of the three tuples (key, value, and version) of the data in the status database. If the data related to normally submitted transaction is changed in the process, then the verification failure will also result in an invalid transaction. In this case, some compensation measures in the application are required, such as adjusting the configuration of the transaction package or resubmitting the failed transaction. In the current version, the invalid transaction stays in the block, and the recorded metadata of in the block can be used to determine which transactions are invalid. The TxRwSet of invalid transactions will not be submitted to the status database, nor will it cause changes in the status database. It will only increase the occupation of the space of the block and the hard disk space of the accounting node. Subsequent versions will simplify the ledger and filter out invalid transactions.
Four、Message protocol structure
1．Structure of envelop message
　Envelop message is the most basic unit in verification. It consists of a Payload and a Signature.
message Envelope {　　
　　bytes payload = 1;
　　bytes signature = 2;
}
　　　　Header header = 1;
　　　　bytes data = 2;
}
　　Payload contains：
　　1) Message header. The header has a type that describes the nature of the load and how to ungroup the data fields. In addition, the header contains information of the creator and random numbers, as well as the time information used to identify the time logic window. The Peer node can accept an envelope only if both conditions are valid.
　　2) The type of the data field is specified by the header. The organization of the head message is as follows:：
　　message Header {
　　bytes channel_header = 1;
　　bytes signature_header = 2;
}
　message ChannelHeader {
　　int32 type = 1;
　　　　int32 version = 2;
　　　　google.protobuf.Timestamp timestamp = 3;
　　　string channel_id = 4;
　　　string tx_id = 5;
　　　　uint64 epoch = 6;
　　　　bytes extension = 7;
}
enum HeaderType {
　　MESSAGE = 0;　　　　　　　　　
　　CONFIG = 1;　　　　　　　　　　
　　CONFIG_UPDATE = 2;　　　　　　
　　ENDORSER_TRANSACTION = 3;　　
　　ORDERER_TRANSACTION = 4;　　　 
　　DELIVER_SEEK_INFO = 5;　　　　 

　　CHAINCODE_PACKAGE = 6;　　　　 
}
message SignatureHeader {
　　　　bytes nonce = 2;
}
　　The envelope message structure is necessary to verify the signature of the payload. Otherwise, for a large payload message, all the loads must be connected before the signature verification, which is often costly. After sorting, the envelope message batch is delivered to the accounting node for verification, and the verified data is recorded into the account book.
	2. Configuration management structure
The blockchain has associated configuration. Configuration is set in the creation block, but may be modified later. This configuration information is encoded in the envelope message with the type of CONFIGURATION_TRANSACTION. The configuration information itself is a separate transaction of the block. Configuration information transactions are totally dependent, so each configuration information transaction must contain the full data of the chain, not just the increment. It is easier to guide new peers or sort nodes with full data, and to tailor the work in the future. Envelope message of the CONFIGURATION_TRANSACTION type has payload data of the Configuration Envelope type.
It is defined as： 
　　message ConfigurationEnvelope {
　　repeated SignedConfigurationItem Items = 3;
}
　　The envelope message of the configuration has associated serial numbers and chain IDs. The serial number must be incremented with every change of the configuration, which can be a simple mechanism to prevent replay attacks. A sequence of SignedConfigurationItems is embedded in the envelope of configuration information, defined as follows.：
　　message SignedConfigurationItem { 　　
　　bytes ConfigurationItem = 1;
　　repeated Envelope Signatures = 2;
}
　　Because SignedConfigurationItem must support multiple signatures, it contains a set of duplicate envelope messages. Each of these messages has a header of CONFIGURATION_ITEM type. The data of the load is saved in the ConfigurationItem, which is defined as:：
message ConfigurationItem { 　　
enum ConfigurationType {
　　　　Policy = 0;
　　　　Chain = 1;
　　　　Orderer = 2;
　　　　Fabric = 3;
}
　　uint64 LastModified = 2;
　　ConfigurationType Type = 3;
　　string ModificationPolicy = 4;
　　string Key = 5;
　　bytes Value = 6;
}
　　Type provides the scope and encoding information for the configuration items. The LastModified field is set to be the serial number in the information envelope when the configuration item was last modified. ModificationPolicy points to a named policy to evaluate future signatures to determine whether the changes are authorized. The Key and Value fields are used respectively for reference configuration items and their contents. Any one that has the right to change the configuration item can build a new configuration information transaction. Modifying the configuration item will update the serial number and create a new creation block. Various nodes newly added to the network will be guided by the newly created block.
3. Endorsement process structure
The ENDORSER_TRANSACTION is used when Envelope.data carries messages related to the chain code. The load process of approved ENDORSER_TRANSACTION is as follows.
First, the client sends a proposal message to all relevant endorsement nodes (the proposal will affect the ledger in general).
Then each endorsement node sends a proposal response message to the client. The proposal response contains the success/error code, response load and signature of the endorsement result. The response payload contains the hash value information of the proposal, which can be used to securely connect the proposal to the response.
Finally, the client writes the endorsement results to the transaction, sign and sent it to the sorting service.
1) Transaction proposal structure
A proposal message contains the header (contains some metadata describing it, such as the type, identity of the caller, the chain ID, encrypted random numbers) and opaque load: 
message SignedProposal {

　　bytes proposal_bytes = 1;　　
　　bytes signature = 2;
}
message Proposal {　　
　　bytes header = 1;　　
　　bytes payload = 2;　　
　　bytes extension = 3;
}
　　When the endorsement node receives the signed proposal message, it will verify the signature in the message. Verifying the signature requires the following steps.
* Pre-validation of the validity of the signature certificate generated by the user. Once the SignedProposal. Proposal_bytes and Proposal.header are all successful parsed, the certificate is assumed to be valid. Although the parsing operation might not be ideal before certificate validation, this process can filter out the expired certificate.
* Check the validity of the certificate (whether signed by a trusted CA), and permit the transaction (ACL check)
* Check the validity of the signature of SignedProposal.proposal_bytes
* Check the replay attack
　　The following is the message when the ChainHeader type is ENDORSER_TRANSACTION:
message ChaincodeHeaderExtension {
　　　bytes payload_visibility = 1;　　
　　ChaincodeID chaincode_id = 2;
}
　　The ChaincodeHeaderExtension message is used to specify the chain code to be invoked and what should be presented in the ledger. Ideally, payload_visibility is configurable and supports at least three main visibility patterns：
* Every bytes of the load is visible
* Only Hash value of the load is visible
* Nothing visible
2) Proposal response structure.
The proposal response message is returned from the endorsement node to the proposal client. The endorsement node uses this message to express the processing result of the transaction proposal. The answer may be either a success or a failure. Action description and signatures of endorsement nodes are also included in the answer.
If the same action is approved and signed by sufficient number of endorsement nodes, then load messages can be generated and sent to the sorting node. 
message ProposalResponse {　　
　　int32 version = 1;　　
　　google.protobuf.Timestamp timestamp = 2;　　
　　Response response = 4;
　　　　bytes payload = 5;
　　　Endorsement endorsement = 6;
}
message ProposalResponsePayload {
　　　　bytes proposal_hash = 1;
　　　　bytes extension = 2;
}
message Endorsement {
　　　　bytes endorser = 1;
　　　　bytes signature = 2;
}
　　The proposal_hash field connects the transaction proposal and the proposal response, which is to realize the billing function of the asynchronous system. It is also a safety appeal to claim responsibility and anti-repudiation. The hash value usually covers all the bytes of the entire proposal message. However, this means that the validity of the hash value cannot be verified unless the complete proposal message is collected.
　　For confidentiality, the payload of the proposal is unlikely stored directly in the ledger when using the chain code. For example, message of ENDORSER_TRANSACTION type deals with the header and the payload of the proposal separately: the header is always completely hashed while the payload may be conducted a complete hash or re-hashed the hash value, or non-hashed at all.
　　3) Endorsement transaction structure
　　After the client has received enough endorsement, these endorsements can be combined into transaction information. This transaction information can be set as the field of the payload. The following is the specific message used in this case: 
message Transaction {
　　　　repeated TransactionAction actions = 1;
}
message TransactionAction {
　　　　bytes header = 1;
　　　　bytes payload = 2;
}
The ChaincodeEndorsedAction message carries the endorsement information about a specific proposal. The proposalResponsePayload is signed by the endorsement node. For the ENDORSER_TRANSACTION, the extension field of proposalResponsePayload will have a ChaincodeAction. In addition, the endorsements field contains the received endorsement information of the proposal.
Five、Policy management and access control
　　In FXCO, policy management is used in many conditions. It is a method of access management, including transaction endorsement policy, chain code instantiation policy and channel management policy, etc.
	1. Transaction endorsement policy
A transaction endorsement policy is a protocol that endorses a transaction, which is related to the channel and chain code and is specified when the chain code is instantiated. When the chain code is called, it is necessary to collect sufficient signatures from the endorsement node. Only those transactions those satisfying the endorsement policy are valid. It is achieved by the interaction between the application and the endorsement node which is already introduced in the previous transaction process.
　　2. Chain code instantiation policy
　　The chain code instantiation policy is used to verify the right for chain code instantiation and chain code upgrading. The chain code instantiation policy is specified when the chain code is packaged and signed. If the instantiation policy is not specified, only the administrator of the channel can carry out the instantiation by default.
type SignedChaincodeDeploymentSpec struct {
　　　　ChaincodeDeploymentSpec []byte
　　　　InstantiationPolicy []byte
　　　　OwnerEndorsements []*Endorsement
}
　　The definition of the chain code instantiation policy is exactly the same as the endorsement policy, and the verification method is the same, except the difference in usages and purposes. The chain code instantiation policy is obtained directly from the chain code packaging and stored on the chain after instantiation. It has to verify compliance with the current instantiation policy before the chain code is instantiated or upgraded. The chain code instantiation policy is then updated after the verification. The chain code information structure stored on the chain is shown as follows:
type ChaincodeData struct {
　　　　Name string
　　　  Version string
　　　　Escc string
　　　　Vscc string
　　　　Policy []byte
　　　　Data []byte
　　　　Id []byte
　　　　InstantiationPolicy []byte
}
　　The chain code information structure, ChaincodeData, is indexed by chain code.
3. Channel management policy
　　Channel configurations are defined by recursion:
type ConfigGroup struct {
　　Version　uint64　　　　　　　　　　
　　Groups　map[string]*ConfigGroup　 
　　Values　map[string]*ConfigValue　 
　　Policies　map[string]*ConfigPolicy　　　
　　ModPolicy  string　　　　　　　　　　
}
From the above definition, we can see that the configuration policy is based on SignaturePolicy and ImplicitMetaPolicy. ModPolicy represents the policy name used to modify policy at the same level. Three configuration policies are defined in the channel, as shown in the table below.
Policy name
Policy implications
Policy instructions
Writers
Channel write access  
Access control policy of any deal submitted to channel. Such as define which identity or organization can submit a deal to chain, control the access that submit the proposal by endorsement nodes 
Readers
Channel read access
Access control policy of any reading permission to the channel. Such as define which identity or organization can read the data on the chain, also includes the right to call the Deliver interface of sorting service and receive events in the channel
Admins
Channel management access
Access control policy of any modification to the channel configuration. Such as define which identity or organization can have administrator access to the channel configuration, it specifies the administrator signature needed to change the channel 

　　This paper introduces the design principles and ideas of FXCO architecture from the aspects of logical structure, node structure, typical transaction process, and message protocol structure and policy management. 

Chapter IV Management organization
　　The FXCO project is managed in the form of a foundation.
　　The foundation is committed to the construction and management of FXCO. The main objective is to ensure the sustainable development of FXCO project, as well as the security and effectiveness of fund raising. The FXCO foundation is composed of the decision committee, the fund autonomous committee and the executive committee. The Management organization represents the operational processes and regulations for daily work and special situations.
　　To avoid the discrepancy of community members in decision or policymaking even split, the foundation community establishes this management organization to explain general things and privileges of the community. The goal of the management organization is to maintain the sustainable development of the platform ecology, decision-making efficiency and capital management regulatory compliance. The foundation is exercised by the decision committee in routine matters.
　　At the expiration of the decision committee, five core members of the decision committee will be voted by the community. The selected core staff represents the foundation to make important and urgent decisions and will be subject to credit investigation during their tenure.
　　To facilitate the development of the project in the early stage of the foundation, the first decision committee consists of team members and early investors. All member serve two-year term. After the expiration, new members will be voted by the community. The decision committee consists of five members, including three originators and two early investors. All decisions are made with a three-fifths multi-signature system.

Chapter V Related instructions of FXCO
One. FXCO outline
　　FXCO is the blood that drives the decentralized FXCO ecosystem. It is mainly used in financial exchanges, international trade settlement, global payment, value saving and so on. In the future, we will encourage organizations to develop sub-chains based on FXCO. By then, FXCO will be the parent chain. The data interaction between sub-chains, the execution of smart contracts and the exchange of assets and information data in every link will consume FXCO tokens. FXCO becomes the smart contract token on the whole foreign exchange ecosystem.
Two. Issuing plan
　　The total circulation of FXCO is 2.1 billion, with 2 billion issued in the FXCO creation block. 15% belongs to technology development, and 15% for the foundation, 10% for the operating team, 10% for business promotion and 50% for private equity..　　

Chapter VI Team introduction
　　All team members in this project are senior experts in related fields, well experienced and riched in resource. A lot of work has been done in the early stage of the project and the results are impressive. 
　　The details are as follows:
　　Artur: the CEO. Senior entrepreneurs in capital trading, Expert. Four years’ experience in foreign exchange trading and three years investigation in the block chain industry. Profound insights of  international settlement and foreign exchange trading.
　　Vova: the CTO. Core translator of bitcoin. Contact with bitcoin and block chain technology since 2013. Hyperledger developer. Intensive research and use of distributed file storage systems such as ipfs. Network security background with a deep understanding of cryptography. Highly experienced in Internet finance, big data, privacy protection, and online high performance service development.
　　Tim: Programmer. Participated in the design of online finance project and studied the block chain technology for three years. Master in Java, C++, ruby, MQTT and blockCity.
　　Daniel: Programmer. Engaged in the financial industry for 4 years, and work on Internet of things based on block chain technology since 2013. Participated in the design of cross-border settlement project and worked as a technical manager of a security company.
　　Investors and distinguished Consultants：
　　Peng ZhongHua: Master geomancy，Founder and CEO of Singapore Xintiandi Group(The world's first feng Shui listed company).Lecturer, Department of Sinology Culture, Nanjing University.FXCO's Investors and distinguished consultants.2010 winner of Singapore successful Entrepreneur Award.He is proficient in Chinese and Western culture, has a number of research initiatives, deeply international attention.

Chapter VII Risk and disclaimer
* As a new investment mode, digital asset investment has various risks, and potential investors should carefully assess the investment risk and their risk tolerance.
* This document is used to guide the progress of the FXCO project, and it is only used to convey the information. It does not constitute the relevant opinions to buy/sell FXCO. The above information or analysis does not constitute an investment decision. This document does not constitute any investment proposal, investment intention or instigation investment.
* This document is not construed to provide any trading activity or any solicitation to buy or sell any form of securities, or contract or commitment in any form.
* Interested users have a clear understanding of the risks of FXCO project. Once investors participate in the investment, they will understand and accept the risk of the project, and they are willing to bear all the corresponding results or consequences.
* The project team is not responsible for any direct or indirect loss of assets caused by the FXCO project.
* Project risk：
> Policy risk. Block chain technology is still in the early stage. There will be uncertainty about the regulatory policies of the blockchain project in different countries. Changes in the operation main body or management policy in local government is possible.
> Fluctuation risk. The tokens of the blockchain project are not legal tender. It is also a kind of TOKEN in block chain project. The price fluctuation might be huge. So investors need to be psychologically resilient.
> Technical risk. With the continuous development of block chain technology, there is no guarantee to avoid technical loopholes and hacker attacks in project operation.
> Team risk. There is no guarantee to avoid the demission of core staffs of FXCO due to pressure, physical problems or personal factors. What can be guaranteed is that team successors will make the project more stable.
